declare enum CurveId {
    BN254 = 0,
    BLS12_381 = 1,
    SECP256K1 = 2,
    SECP256R1 = 3,
    ED25519 = 4
}
interface G1Point$1 {
    x: bigint;
    y: bigint;
    curveId: CurveId;
}
interface G2Point$1 {
    x: [bigint, bigint];
    y: [bigint, bigint];
    curveId: CurveId;
}

interface Groth16Proof {
    a: G1Point$1;
    b: G2Point$1;
    c: G1Point$1;
    publicInputs: bigint[];
    curveId?: CurveId;
    imageIdJournalRisc0?: {
        imageId: Uint8Array;
        journal: Uint8Array;
    };
    vkeyPublicValuesSp1?: {
        vkey: Uint8Array;
        publicValues: Uint8Array;
    };
}
interface Groth16VerifyingKey {
    alpha: G1Point$1;
    beta: G2Point$1;
    gamma: G2Point$1;
    delta: G2Point$1;
    ic: G1Point$1[];
}

declare enum HonkFlavor {
    KECCAK = 0,
    STARKNET = 1
}

/**
 * Represents a point on an elliptic curve in affine coordinates (x, y)
 */
type G1Point = [bigint, bigint];
/**
 * Represents a point on a twisted elliptic curve over an extension field
 * Format: [[x0, x1], [y0, y1]] where x = x0 + x1*i and y = y0 + y1*i
 */
type G2Point = [[bigint, bigint], [bigint, bigint]];
/**
 * Represents a pairing of G1 and G2 points for pairing-based cryptography
 */
type G1G2Pair = [G1Point, G2Point];
/**
 * Configuration options for MSM (Multi-Scalar Multiplication) calldata builder
 */
type MsmCalldataBuilderOptons = Partial<{
    /** Whether to include the original points and scalars in the output */
    includePointsAndScalars: boolean;
    /** Whether to serialize the output as a pure felt252 array for Cairo compatibility */
    serializeAsPureFelt252Array: boolean;
}>;
/**
 * Builds calldata for Multi-Scalar Multiplication (MSM) operations.
 * MSM computes the sum of scalar multiplications: Î£(scalar_i * point_i)
 *
 * @param points - Array of G1 points to be multiplied
 * @param scalars - Array of scalar values for multiplication
 * @param curveId - Identifier for the elliptic curve (e.g., BN254, BLS12_381)
 * @param options - Configuration options for the MSM operation
 * @returns Array of bigint values representing the MSM calldata
 *
 * @example
 * ```typescript
 * const points: G1Point[] = [[1n, 2n], [3n, 4n]];
 * const scalars = [5n, 6n];
 * const calldata = msmCalldataBuilder(points, scalars, CurveId.BN254);
 * ```
 */
declare function msmCalldataBuilder(points: G1Point[], scalars: bigint[], curveId: CurveId, options?: MsmCalldataBuilderOptons): bigint[];
/**
 * Builds calldata for Multi-Pairing Check (MPC) operations.
 * MPC verifies that a set of pairing equations hold: e(G1_i, G2_i) = 1
 *
 * @param curveId - Identifier for the elliptic curve
 * @param pairs - Array of G1-G2 point pairs for pairing
 * @param nFixedG2 - Number of fixed G2 points in the pairing
 * @param publicPair - Optional additional public pairing for verification
 * @returns Array of bigint values representing the MPC calldata
 *
 * @example
 * ```typescript
 * const pairs: G1G2Pair[] = [[[1n, 2n], [[3n, 4n], [5n, 6n]]]];
 * const calldata = mpcCalldataBuilder(CurveId.BN254, pairs, 1);
 * ```
 */
declare function mpcCalldataBuilder(curveId: CurveId, pairs: G1G2Pair[], nFixedG2: number, publicPair?: G1G2Pair): bigint[];
/**
 * Builds calldata for Schnorr signature verification.
 * Schnorr signatures provide a simple and efficient digital signature scheme.
 *
 * @param rx - X-coordinate of the signature point R
 * @param s - Signature scalar value
 * @param e - Challenge hash value
 * @param px - X-coordinate of the public key point
 * @param py - Y-coordinate of the public key point
 * @param curveId - Identifier for the elliptic curve
 * @returns Array of bigint values representing the Schnorr verification calldata
 *
 * @example
 * ```typescript
 * const calldata = schnorrCalldataBuilder(
 *   0x123n, // rx
 *   0x456n, // s
 *   0x789n, // e
 *   0xabcn, // px
 *   0xdefn, // py
 *   CurveId.BN254
 * );
 * ```
 */
declare function schnorrCalldataBuilder(rx: bigint, s: bigint, e: bigint, px: bigint, py: bigint, curveId: CurveId): bigint[];
/**
 * Builds calldata for ECDSA signature verification.
 * ECDSA is the standard elliptic curve digital signature algorithm.
 *
 * @param r - R component of the ECDSA signature
 * @param s - S component of the ECDSA signature
 * @param v - Recovery ID (0 or 1) for public key recovery
 * @param px - X-coordinate of the public key point
 * @param py - Y-coordinate of the public key point
 * @param z - Hash of the signed message
 * @param curveId - Identifier for the elliptic curve
 * @returns Array of bigint values representing the ECDSA verification calldata
 *
 * @example
 * ```typescript
 * const calldata = ecdsaCalldataBuilder(
 *   0x123n, // r
 *   0x456n, // s
 *   0,      // v
 *   0x789n, // px
 *   0xabcn, // py
 *   0xdefn, // z (message hash)
 *   CurveId.SECP256K1
 * );
 * ```
 */
declare function ecdsaCalldataBuilder(r: bigint, s: bigint, v: number, px: bigint, py: bigint, z: bigint, curveId: CurveId): bigint[];
/**
 * Builds calldata for EdDSA signature verification for Ed25519.
 * EdDSA provides deterministic signatures with strong security properties.
 *
 * @param ry_twisted_le - Y-coordinate of signature point R in twisted Edwards form (little-endian)
 * @param s - Signature scalar value
 * @param py_twisted_le - Y-coordinate of public key in twisted Edwards form (little-endian)
 * @param msg - Raw message bytes that were signed
 * @returns Array of bigint values representing the EdDSA verification calldata
 *
 * @example
 * ```typescript
 * const message = new Uint8Array([1, 2, 3, 4]);
 * const calldata = eddsaCalldataBuilder(
 *   0x123n, // ry_twisted_le
 *   0x456n, // s
 *   0x789n, // py_twisted_le
 *   message
 * );
 * ```
 */
declare function eddsaCalldataBuilder(ry_twisted_le: bigint, s: bigint, py_twisted_le: bigint, msg: Uint8Array): bigint[];
/**
 * Converts a point from twisted Edwards form to Weierstrass form for Ed25519.
 * This is useful for interoperability between different curve representations.
 *
 * @param x_twisted - X-coordinate in twisted Edwards form
 * @param y_twisted - Y-coordinate in twisted Edwards form
 * @returns Tuple of [x_weierstrass, y_weierstrass] coordinates
 * @throws Error if the conversion fails or produces invalid results
 *
 * @example
 * ```typescript
 * const [x_w, y_w] = toWeirstrass(0x123n, 0x456n);
 * console.log(`Weierstrass form: (${x_w}, ${y_w})`);
 * ```
 */
declare function toWeirstrass(x_twisted: bigint, y_twisted: bigint): [bigint, bigint];
/**
 * Converts a point from Weierstrass form to twisted Edwards form for Ed25519.
 * This is useful for interoperability between different curve representations.
 *
 * @param x_weierstrass - X-coordinate in Weierstrass form
 * @param y_weierstrass - Y-coordinate in Weierstrass form
 * @returns Tuple of [x_twisted, y_twisted] coordinates
 * @throws Error if the conversion fails or produces invalid results
 *
 * @example
 * ```typescript
 * const [x_t, y_t] = toTwistedEdwards(0x789n, 0xabcn);
 * console.log(`Twisted Edwards form: (${x_t}, ${y_t})`);
 * ```
 */
declare function toTwistedEdwards(x_weierstrass: bigint, y_weierstrass: bigint): [bigint, bigint];
/**
 * Generates calldata for Groth16 zero-knowledge proof verification.
 * Groth16 is a succinct non-interactive zero-knowledge proof system.
 *
 * @param proof - The Groth16 proof containing points A, B, C and public inputs
 * @param verifyingKey - The verification key containing curve points for verification
 * @param curveId - Identifier for the elliptic curve used in the proof
 * @returns Array of bigint values representing the complete verification calldata
 *
 * @example
 * ```typescript
 * const proof: Groth16Proof = {
 *   a: [0x123n, 0x456n],
 *   b: [[0x789n, 0xabcn], [0xdefn, 0x111n]],
 *   c: [0x222n, 0x333n],
 *   publicInputs: [0x444n, 0x555n]
 * };
 * const calldata = getGroth16CallData(proof, verifyingKey, CurveId.BN254);
 * ```
 */
declare function getGroth16CallData(proof: Groth16Proof, verifyingKey: Groth16VerifyingKey, curveId: CurveId): bigint[];
/**
 * Generates calldata for Honk zero-knowledge proof verification.
 * Honk is a universal SNARK that supports arbitrary circuits.
 *
 * @param proof - Raw proof bytes from the Honk prover
 * @param publicInputs - Public input bytes for the circuit
 * @param verifyingKey - Verification key bytes for the specific circuit
 * @param flavor - The Honk flavor (variant) being used
 * @returns Array of bigint values representing the complete verification calldata
 *
 * @example
 * ```typescript
 * const proofBytes = new Uint8Array([...]);
 * const publicInputsBytes = new Uint8Array([...]);
 * const vkBytes = new Uint8Array([...]);
 * const calldata = getHonkCallData(proofBytes, publicInputsBytes, vkBytes, HonkFlavor.STARKNET);
 * ```
 */
declare function getHonkCallData(proof: Uint8Array, publicInputs: Uint8Array, verifyingKey: Uint8Array, flavor: HonkFlavor): bigint[];
/**
 * Generates calldata for ZK-Honk zero-knowledge proof verification.
 * ZK-Honk provides zero-knowledge properties on top of the Honk system.
 *
 * @param proof - Raw ZK proof bytes from the ZK-Honk prover
 * @param publicInputs - Public input bytes for the circuit
 * @param verifyingKey - Verification key bytes for the specific circuit
 * @param flavor - The Honk flavor (variant) being used with ZK properties
 * @returns Array of bigint values representing the complete verification calldata
 *
 * @example
 * ```typescript
 * const zkProofBytes = new Uint8Array([...]);
 * const publicInputsBytes = new Uint8Array([...]);
 * const vkBytes = new Uint8Array([...]);
 * const calldata = getZKHonkCallData(zkProofBytes, publicInputsBytes, vkBytes, HonkFlavor.KECCAK);
 * ```
 */
declare function getZKHonkCallData(proof: Uint8Array, publicInputs: Uint8Array, verifyingKey: Uint8Array, flavor: HonkFlavor): bigint[];
/**
 * Represents a randomness beacon from the drand network
 */
type DrandRandomnessBeacon = {
    /** The round number of this randomness beacon */
    round: number;
    /** The random value generated for this round */
    randomness: bigint;
    /** The BLS signature proving the randomness */
    signature: bigint;
};
/**
 * Fetches drand randomness and generates verification calldata in one step.
 * This is a convenience function that combines fetching and calldata generation.
 *
 * @param roundNumber - The specific round to fetch, or 'latest' for the most recent
 * @param chainHash - Hash identifier of the drand chain (defaults to quicknet)
 * @param baseUrls - Array of drand API endpoints to try
 * @returns Promise resolving to calldata array for verifying the drand randomness
 *
 * @example
 * ```typescript
 * // Fetch latest randomness and generate calldata
 * const calldata = await fetchAndGetDrandCallData();
 *
 * // Fetch specific round
 * const roundCalldata = await fetchAndGetDrandCallData(12345);
 * ```
 */
declare function fetchAndGetDrandCallData(roundNumber?: number | 'latest', chainHash?: string, baseUrls?: string[]): Promise<bigint[]>;
/**
 * Generates calldata for drand randomness beacon verification.
 * This prepares the data needed to verify a drand signature on-chain.
 *
 * @param beacon - The drand randomness beacon containing round, randomness, and signature
 * @returns Array of bigint values representing the verification calldata
 *
 * @example
 * ```typescript
 * const beacon = {
 *   round: 12345,
 *   randomness: 0x123456789n,
 *   signature: 0xabcdef123n
 * };
 * const calldata = getDrandCallData(beacon);
 * ```
 */
declare function getDrandCallData({ round, randomness, signature }: DrandRandomnessBeacon): bigint[];
/**
 * Fetches randomness data from the drand distributed randomness beacon network.
 * Tries multiple endpoints for reliability and returns the first successful response.
 *
 * @param roundNumber - The specific round to fetch, or 'latest' for the most recent
 * @param chainHash - Hash identifier of the drand chain to query
 * @param baseUrls - Array of drand API endpoints to attempt
 * @returns Promise resolving to the randomness beacon data
 * @throws Error if all endpoints fail or return invalid data
 *
 * @example
 * ```typescript
 * // Fetch latest round
 * const latest = await fetchDrandRandomness();
 *
 * // Fetch specific round
 * const round12345 = await fetchDrandRandomness(12345);
 *
 * // Use custom endpoints
 * const custom = await fetchDrandRandomness('latest', 'custom-hash', ['https://custom-drand.com']);
 * ```
 */
declare function fetchDrandRandomness(roundNumber?: number | 'latest', chainHash?: string, baseUrls?: string[]): Promise<DrandRandomnessBeacon>;
/**
 * Computes the Poseidon hash function over the BN254 curve.
 * Poseidon is a cryptographic hash function optimized for zero-knowledge circuits.
 *
 * @param x - First input field element
 * @param y - Second input field element
 * @returns The Poseidon hash result as a bigint
 * @throws Error if the hash computation fails or inputs are invalid
 *
 * @example
 * ```typescript
 * const hash = poseidonHashBN254(1n, 2n);
 * console.log(`Poseidon(1, 2) = ${hash.toString(16)}`);
 *
 * // Expected output for (1, 2):
 * // 115CC0F5E7D690413DF64C6B9662E9CF2A3617F2743245519E19607A4417189A
 * ```
 */
declare function poseidonHashBN254(x: bigint, y: bigint): bigint;

/* tslint:disable */
/* eslint-disable */
declare function drand_calldata_builder(values: any[]): any[];
declare function msm_calldata_builder(values: any[], scalars: any[], curve_id: number, include_points_and_scalars: boolean, serialize_as_pure_felt252_array: boolean): any[];
declare function mpc_calldata_builder(curve_id: number, values1: any[], n_fixed_g2: number, values2: any[]): any[];
declare function schnorr_calldata_builder(rx: any, s: any, e: any, px: any, py: any, curve_id: number): any[];
declare function ecdsa_calldata_builder(r: any, s: any, v: number, px: any, py: any, z: any, curve_id: number): any[];
declare function eddsa_calldata_builder(ry_twisted: any, s: any, py_twisted: any, msg: any): any[];
declare function to_weirstrass(x_twisted: any, y_twisted: any): any[];
declare function to_twistededwards(x_weirstrass: any, y_weirstrass: any): any[];
declare function get_groth16_calldata(proof_js: any, vk_js: any, curve_id_js: any): any[];
declare function parse_honk_proof(proof_js: any, public_inputs_js: any): any;
declare function get_honk_calldata(proof_js: any, public_inputs_js: any, vk_js: any, flavor_js: any): any[];
declare function get_zk_honk_calldata(proof_js: any, public_inputs_js: any, vk_js: any, flavor_js: any): any[];
declare function poseidon_hash(x: any, y: any): any;

type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly drand_calldata_builder: (a: number, b: number, c: number) => void;
  readonly msm_calldata_builder: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => void;
  readonly mpc_calldata_builder: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly schnorr_calldata_builder: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly ecdsa_calldata_builder: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => void;
  readonly eddsa_calldata_builder: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly to_weirstrass: (a: number, b: number, c: number) => void;
  readonly to_twistededwards: (a: number, b: number, c: number) => void;
  readonly get_groth16_calldata: (a: number, b: number, c: number, d: number) => void;
  readonly parse_honk_proof: (a: number, b: number, c: number) => void;
  readonly get_honk_calldata: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly get_zk_honk_calldata: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly poseidon_hash: (a: number, b: number, c: number) => void;
  readonly __wbindgen_exn_store: (a: number) => void;
  readonly __wbindgen_malloc: (a: number, b: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number, d: number) => number;
  readonly __wbindgen_add_to_stack_pointer: (a: number) => number;
  readonly __wbindgen_free: (a: number, b: number, c: number) => void;
}

type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {{ module: SyncInitInput }} module - Passing `SyncInitInput` directly is deprecated.
*
* @returns {InitOutput}
*/
declare function initSync(module: { module: SyncInitInput } | SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {{ module_or_path: InitInput | Promise<InitInput> }} module_or_path - Passing `InitInput` directly is deprecated.
*
* @returns {Promise<InitOutput>}
*/
declare function __wbg_init (module_or_path?: { module_or_path: InitInput | Promise<InitInput> } | InitInput | Promise<InitInput>): Promise<InitOutput>;

declare function init(): ReturnType<typeof __wbg_init>;

export { CurveId, type G1G2Pair, type G1Point, type G2Point, type InitInput, type InitOutput, type MsmCalldataBuilderOptons, type SyncInitInput, drand_calldata_builder, ecdsaCalldataBuilder, ecdsa_calldata_builder, eddsaCalldataBuilder, eddsa_calldata_builder, fetchAndGetDrandCallData, fetchDrandRandomness, getDrandCallData, getGroth16CallData, getHonkCallData, getZKHonkCallData, get_groth16_calldata, get_honk_calldata, get_zk_honk_calldata, init, initSync, mpcCalldataBuilder, mpc_calldata_builder, msmCalldataBuilder, msm_calldata_builder, parse_honk_proof, poseidonHashBN254, poseidon_hash, schnorrCalldataBuilder, schnorr_calldata_builder, toTwistedEdwards, toWeirstrass, to_twistededwards, to_weirstrass };
